import prismaClient from '../utils/db.js';
import { uploadFileToS3, getFileFromS3, getDownloadUrlFromS3 } from '../utils/aws-s3.js'

// NOTE : filePath is by default unique 
// due to the way it will be generated by aws-sdk so can be used as slug

const checkCollectionsOwnership = async (collectionIds, userId) => {
    for (const collectionId of collectionIds) {
        const collection = await prismaClient.collection.findUnique({
            where: { id: collectionId }
        });
        if (!collection || collection.ownerId !== userId) {
            return [false, `Invalid collection ID or access denied for collection ID: ${collectionId}`];
        }
    }
    return [true, ""];
}

export const createFile = async (req, res) => {
    try {
        const { fileName, collections: rawCollectionIdsArray } = req.body;
        // Raw collectionIdsArray is stringified array from frontend its type on backend is string
        if (!fileName || !rawCollectionIdsArray) {
            return res.status(400).json({ message: 'File name and collections are required.' });
        }
        const collectionIds = Array.isArray(rawCollectionIdsArray) ? rawCollectionIdsArray : JSON.parse(rawCollectionIdsArray);
        const userId = req.user.userId;

        const [isValidCollections, errorMessage] = await checkCollectionsOwnership(collectionIds, userId);
        if (!isValidCollections) {
            return res.status(403).json({ message: errorMessage });
        }

        // now upload this file to S3 and get the filePath
        console.log('req.files:', req.files);
        const fileLocalPath = req.files.document ? req.files.document[0].path : null;
        if(!fileLocalPath){
            return res.status(409).json({ message: "File is required but no local path is available" });
        }
        const fileKey = await uploadFileToS3(userId, fileLocalPath, fileName); // TODO : Here unlink the local file after upload in finally block so it does not stay on server anyhow
        console.log('fileKey from S3:', fileKey);
        if (!fileKey) {
            return res.status(500).json({ message: 'Error uploading file to S3.' });
        }

        const newFile = await prismaClient.file.create({
            data: {
                fileName,
                filePath: fileKey,
                ownerId: userId,
                collections: {
                    connect: collectionIds.map(id => ({ id }))
                }
            }
        });

        return res.status(201).json({ message: 'File created successfully', newFile });
    } catch (error) {
        console.error('Error creating file:', error);
        res.status(500).json({ message: 'Internal server error' });
    }
}

export const getAllFiles = async (req, res) => {
    const userId = req.user.userId;
    const order = req.query.order || 'desc';
    const qty = parseInt(req.query.qty) || 20;
    const page = parseInt(req.query.page) || 1;

    try {
        const files = await prismaClient.file.findMany({
            where: { ownerId: userId }
        });
        const sortedFiles = order === 'asc'
            ? files.sort((a, b) => a.createdAt - b.createdAt)
            : files.sort((a, b) => b.createdAt - a.createdAt);

        const paginatedFiles = sortedFiles.slice((page - 1) * qty, page * qty);

        res.status(200).json({
            info: {
                page: page,
                qty: qty,
                order: order,
            },
            count: {
                total: files.length,
                current: paginatedFiles.length,
            },
            files: paginatedFiles
        });
    } catch (error) {
        console.error('Error fetching files:', error);
        res.status(500).json({ message: 'Internal server error' });
    }
}

export const getFile = async (req, res) => {
    const { fileId, mode } = req.body;
    //mode = view | download
    const userId = req.user.userId;

    try {
        const file = await prismaClient.file.findUnique({
            where: { id: fileId, ownerId: userId }
        });

        if (!file) {
            return res.status(404).json({ message: 'File not found or access denied' });
        }

        const fileUrl = mode === "view" ? await getFileFromS3(file.filePath) : await getDownloadUrlFromS3(file.filePath, file.fileName);
        res.status(200).json({ file: { ...file, fileUrl } });
    } catch (error) {
        console.error('Error fetching file:', error);
        res.status(500).json({ message: 'Internal server error' });
    }
}


export const renameFile = async (req, res) => {
    const { fileId, newFileName } = req.query;
    const userId = req.user.userId;

    if (!fileId || !newFileName) {
        return res.status(400).json({ message: 'fileId and newFileName are required.' });
    }

    try {
        const file = await prismaClient.file.findUnique({
            where: { id: fileId }
        });

        if (!file || file.ownerId !== userId) {
            return res.status(404).json({ message: 'File not found or access denied' });
        }

        const updatedFile = await prismaClient.file.update({
            where: { id: fileId },
            data: { fileName: newFileName }
        });

        res.status(200).json({ message: 'File renamed successfully', updatedFile });
    } catch (error) {
        console.log('Error renaming file:', error);
        res.status(500).json({ message: 'Internal server error' });
    }
}

export const deleteFile = async (req, res) => { 
    const { fileId } = req.query;
    const userId = req.user.userId;

    try {
        const file = await prismaClient.file.findUnique({
            where: { id: fileId }
        });

        if (!file || file.ownerId !== userId) {
            return res.status(404).json({ message: 'File not found or access denied' });
        }

        await prismaClient.file.delete({
            where: { id: fileId }
        });

        res.status(200).json({ message: 'File deleted successfully' });
    } catch (error) {
        console.error('Error deleting file:', error);
        res.status(500).json({ message: 'Internal server error' });
    }
}